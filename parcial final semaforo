module semaforo_doble_via_ldr_simple (
    input  wire clk,       // Reloj FPGA 50 MHz
    input  wire rst_n,     // Reset activo bajo
    input  wire ldr,       // 1 = luz, 0 = completamente oscuro

    // NORTE-SUR
    output reg green_ns,
    output reg yellow_ns,
    output reg red_ns,

    // ESTE-OESTE
    output reg green_eo,
    output reg yellow_eo,
    output reg red_eo
);

    // -------------------------------------------------
    // TIEMPOS (50 MHz)
    // -------------------------------------------------
    localparam GREEN_TIME  = 36'd3500000000; // 70s
    localparam YELLOW_TIME = 36'd1000000000; // 20s
    localparam RED_TIME    = 36'd4500000000; // 90s
    localparam BLINK_TIME  = 36'd25000000;   // 0.5s parpadeo amarillo

    // -------------------------------------------------
    // ESTADOS SEMÁFORO
    // -------------------------------------------------
    localparam S_GREEN  = 2'd0;
    localparam S_YELLOW = 2'd1;
    localparam S_RED    = 2'd2;

    reg [1:0] state_ns;
    reg [1:0] state_eo;
    reg [35:0] count;
    reg yellow_on;

    // -------------------------------------------------
    // LÓGICA PRINCIPAL
    // -------------------------------------------------
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state_ns <= S_GREEN;
            state_eo <= S_RED;
            count <= 0;

            green_ns  <= 1; yellow_ns <= 0; red_ns <= 0;
            green_eo  <= 0; yellow_eo <= 0; red_eo <= 1;

            yellow_on <= 0;

        end else begin

            if (ldr == 0) begin
                // ---------- MODO NOCTURNO (oscuro total) ----------
                if (count < BLINK_TIME)
                    count <= count + 1;
                else begin
                    yellow_on <= ~yellow_on;
                    count <= 0;
                end

                // Apagar todos los demás semáforos
                green_ns  <= 0;
                red_ns    <= 0;
                green_eo  <= 0;
                red_eo    <= 0;
                yellow_ns <= yellow_on;
                yellow_eo <= yellow_on;

            end else begin
                // ---------- MODO DIURNO (normal) ----------
                case (state_ns)

                    S_GREEN: begin
                        green_ns  <= 1; yellow_ns <= 0; red_ns <= 0;
                        green_eo  <= 0; yellow_eo <= 0; red_eo <= 1;
                        if (count < GREEN_TIME)
                            count <= count + 1;
                        else begin
                            state_ns <= S_YELLOW;
                            state_eo <= S_RED;
                            count <= 0;
                        end
                    end

                    S_YELLOW: begin
                        green_ns  <= 0; yellow_ns <= 1; red_ns <= 0;
                        green_eo  <= 0; yellow_eo <= 0; red_eo <= 1;
                        if (count < YELLOW_TIME)
                            count <= count + 1;
                        else begin
                            state_ns <= S_RED;
                            state_eo <= S_GREEN;
                            count <= 0;
                        end
                    end

                    S_RED: begin
                        green_ns  <= 0; yellow_ns <= 0; red_ns <= 1;
                        case (state_eo)
                            S_GREEN: begin
                                green_eo  <= 1; yellow_eo <= 0; red_eo <= 0;
                                if (count < GREEN_TIME)
                                    count <= count + 1;
                                else begin
                                    state_eo <= S_YELLOW;
                                    count <= 0;
                                end
                            end
                            S_YELLOW: begin
                                green_eo  <= 0; yellow_eo <= 1; red_eo <= 0;
                                if (count < YELLOW_TIME)
                                    count <= count + 1;
                                else begin
                                    state_eo <= S_RED;
                                    state_ns <= S_GREEN;
                                    count <= 0;
                                end
                            end
                            S_RED: begin
                                green_eo  <= 0; yellow_eo <= 0; red_eo <= 1;
                                if (count < RED_TIME)
                                    count <= count + 1;
                                else begin
                                    state_ns <= S_GREEN;
                                    state_eo <= S_RED;
                                    count <= 0;
                                end
                            end
                        endcase
                    end

                endcase
            end

        end
    end

endmodule
