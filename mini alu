// ---------------------------
// Full Adder 1 bit
// ---------------------------
module full_adder(
    input A, B, Cin,
    output S, Cout
);
    wire w1, w2, w3;
    xor (w1, A, B);
    xor (S, w1, Cin);
    and (w2, A, B);
    and (w3, w1, Cin);
    or  (Cout, w2, w3);
endmodule

// ---------------------------
// Sumador de 8 bits
// ---------------------------
module adder8(
    input [7:0] A, B,
    input Cin,
    output [7:0] SUM,
    output Cout
);
    wire [6:0] carry;
    
    full_adder FA0(A[0], B[0], Cin, SUM[0], carry[0]);
    full_adder FA1(A[1], B[1], carry[0], SUM[1], carry[1]);
    full_adder FA2(A[2], B[2], carry[1], SUM[2], carry[2]);
    full_adder FA3(A[3], B[3], carry[2], SUM[3], carry[3]);
    full_adder FA4(A[4], B[4], carry[3], SUM[4], carry[4]);
    full_adder FA5(A[5], B[5], carry[4], SUM[5], carry[5]);
    full_adder FA6(A[6], B[6], carry[5], SUM[6], carry[6]);
    full_adder FA7(A[7], B[7], carry[6], SUM[7], Cout);
endmodule

// ---------------------------
// ALU de 8 bits completa (ROL/ROR compatible FPGA)
// ---------------------------
module ALU_8bit(
    input  [7:0] A, B,
    input  [3:0] SEL,          // selector de operación
    input  [2:0] imm,          // inmediato para ROL, ROR y suma inmediata
    output [7:0] RESULT,       // LEDs
    output [3:0] FLAGS         // {Z, N, C, P}
);
    // ---------------------------
    // Suma / Resta
    // ---------------------------
    wire [7:0] B_mux = (SEL == 4'b0001) ? ~B : B;
    wire Cin = (SEL == 4'b0001) ? 1'b1 : 1'b0;

    wire [7:0] add_res;
    wire add_carry;
    adder8 SUMADOR(A, B_mux, Cin, add_res, add_carry);

    // ---------------------------
    // Otras operaciones
    // ---------------------------
    wire [7:0] and_res = A & B;
    wire [7:0] or_res  = A | B;
    wire [7:0] xor_res = A ^ B;

    // ---------------------------
    // ROL (rotación izquierda) usando multiplexor
    // ---------------------------
    wire [7:0] rol_res;
    assign rol_res = (imm == 3'd0) ? A :
                     (imm == 3'd1) ? {A[6:0], A[7]} :
                     (imm == 3'd2) ? {A[5:0], A[7:6]} :
                     (imm == 3'd3) ? {A[4:0], A[7:5]} :
                     (imm == 3'd4) ? {A[3:0], A[7:4]} :
                     (imm == 3'd5) ? {A[2:0], A[7:3]} :
                     (imm == 3'd6) ? {A[1:0], A[7:2]} :
                     (imm == 3'd7) ? {A[0], A[7:1]} : A;

    // ---------------------------
    // ROR (rotación derecha) usando multiplexor
    // ---------------------------
    wire [7:0] ror_res;
    assign ror_res = (imm == 3'd0) ? B :
                     (imm == 3'd1) ? {B[0], B[7:1]} :
                     (imm == 3'd2) ? {B[1:0], B[7:2]} :
                     (imm == 3'd3) ? {B[2:0], B[7:3]} :
                     (imm == 3'd4) ? {B[3:0], B[7:4]} :
                     (imm == 3'd5) ? {B[4:0], B[7:5]} :
                     (imm == 3'd6) ? {B[5:0], B[7:6]} :
                     (imm == 3'd7) ? {B[6:0], B[7]} : B;

    // Multiplicación (parte baja)
    wire [15:0] mul_tmp;
    wire [7:0] mul_res;
    assign mul_tmp = A * B;
    assign mul_res = mul_tmp[7:0];

    // Comparación signed
    wire [7:0] cmp_res = ($signed(A) < $signed(B)) ? 8'h01 : 8'h00;

    // Suma inmediata
    wire [7:0] add_imm_res = A + {4'b0000, imm};

    // NOT
    wire [7:0] not_res = ~A;

    // ---------------------------
    // Multiplexor principal
    // ---------------------------
    assign RESULT = (SEL == 4'b0000) ? add_res :
                    (SEL == 4'b0001) ? add_res :
                    (SEL == 4'b0010) ? and_res :
                    (SEL == 4'b0011) ? or_res :
                    (SEL == 4'b0100) ? xor_res :
                    (SEL == 4'b0101) ? rol_res :
                    (SEL == 4'b0110) ? ror_res :
                    (SEL == 4'b0111) ? mul_res :
                    (SEL == 4'b1000) ? cmp_res :
                    (SEL == 4'b1001) ? add_imm_res :
                    (SEL == 4'b1010) ? not_res :
                    8'b00000000;

    // ---------------------------
    // Carry solo en suma/resta
    // ---------------------------
    wire C_flag = (SEL == 4'b0000) ? add_carry :
                  (SEL == 4'b0001) ? add_carry : 1'b0;

    // ---------------------------
    // FLAGS = {Z, N, C, P}
    // ---------------------------
    assign FLAGS[3] = (RESULT == 8'b0);  // Z
    assign FLAGS[2] = RESULT[7];         // N
    assign FLAGS[1] = C_flag;            // C
    assign FLAGS[0] = ~(^RESULT);        // P (1 si par)
endmodule

    
