module semaforo_doble_via_ldr_simple (
    input  wire clk,       // 50 MHz
    input  wire rst_n,     // Reset activo bajo
    input  wire pause,     // Botón PAUSA (toggle)
    input  wire ldr,       // 1 = luz, 0 = oscuro

    // SEMÁFOROS NS
    output reg green_ns,
    output reg yellow_ns,
    output reg red_ns,

    // SEMÁFOROS EO
    output reg green_eo,
    output reg yellow_eo,
    output reg red_eo,

    // DISPLAY 7 SEGMENTOS NS
    output reg [6:0] seg_dec,
    output reg [6:0] seg_uni,

    // DISPLAY 7 SEGMENTOS EO
    output reg [6:0] seg_dec_eo,
    output reg [6:0] seg_uni_eo,

    // LUCES PEATONALES NS
    output reg ped_ns_verde,
    output reg ped_ns_rojo,

    // LUCES PEATONALES EO
    output reg ped_eo_verde,
    output reg ped_eo_rojo
);

    // ============================================================
    // PAUSA RETENSIVA (TOGGLE) con sincronización y ANTI-REBOTE
    // ============================================================
    reg pause_sync_1, pause_sync_2;
    reg pause_clean;            // señal limpia (debounced)
    reg pause_clean_last;
    reg pause_state = 0;

    // sincroniza la señal externa 'pause' a clk para evitar metastabilidad
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            pause_sync_1 <= 1'b0;
            pause_sync_2 <= 1'b0;
        end else begin
            pause_sync_1 <= pause;
            pause_sync_2 <= pause_sync_1;
        end
    end

    // debounce simple: requiere que la señal sincronizada permanezca en 1
    // por un tiempo para considerarla "pressed". umbral = 1_000_000 (20 ms).
    reg [19:0] pause_db_cnt = 0;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            pause_db_cnt <= 0;
            pause_clean <= 1'b0;
        end else begin
            if (pause_sync_2) begin
                if (pause_db_cnt < 1_000_000)
                    pause_db_cnt <= pause_db_cnt + 1;
                if (pause_db_cnt == 1_000_000)
                    pause_clean <= 1'b1;
            end else begin
                pause_db_cnt <= 0;
                pause_clean <= 1'b0;
            end
        end
    end

    // Toggle: detectar flanco limpio (clean rising edge) y alternar pause_state
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            pause_clean_last <= 1'b0;
            pause_state <= 1'b0;
        end else begin
            if (pause_clean && !pause_clean_last)
                pause_state <= ~pause_state;
            pause_clean_last <= pause_clean;
        end
    end

    // ============================================================
    // FILTRO LDR (Anti-ruido / estabilización)
    // ============================================================
    // ldr_stable = 1 cuando la LDR lleva suficiente tiempo en 1 (luz)
    // ldr_stable = 0 cuando la LDR lleva suficiente tiempo en 0 (oscuridad)
    // Umbral ajustable: 2_500_000 ciclos = 50 ms a 50MHz
    reg [21:0] ldr_cnt = 0;
    reg ldr_stable = 0;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            ldr_cnt    <= 22'd0;
            ldr_stable <= 1'b0;
        end else begin
            if (ldr) begin
                if (ldr_cnt < 22'd2_500_000)
                    ldr_cnt <= ldr_cnt + 1;
                if (ldr_cnt == 22'd2_500_000)
                    ldr_stable <= 1'b1;
            end else begin
                if (ldr_cnt > 0)
                    ldr_cnt <= ldr_cnt - 1;
                if (ldr_cnt == 0)
                    ldr_stable <= 1'b0;
            end
        end
    end

    // ============================================================
    //  Tiempos originales (sin cambios)
    // ============================================================
    localparam GREEN_TIME  = 36'd3500000000; 
    localparam YELLOW_TIME = 36'd1000000000; 
    localparam RED_TIME    = 36'd4500000000; 
    localparam BLINK_TIME  = 36'd25000000;   

    // Estados
    localparam S_GREEN  = 2'd0;
    localparam S_YELLOW = 2'd1;
    localparam S_RED    = 2'd2;

    reg [1:0] state_ns;
    reg [1:0] state_eo;
    reg [35:0] count;
    reg yellow_on;

    // ============================================================
    // DIVISOR 1 HZ (tick_1s)
    // ============================================================
    reg [25:0] div_count = 0;
    reg tick_1s = 0;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            div_count <= 0;
            tick_1s <= 0;
        end else if (!pause_state) begin
            if (div_count == 26'd49999999) begin
                div_count <= 0;
                tick_1s <= 1;
            end else begin
                div_count <= div_count + 1;
                tick_1s <= 0;
            end
        end
        // if pause_state == 1 -> div_count and tick_1s keep their values (congelado)
    end

    // ============================================================
    // CONTADORES NS
    // ============================================================
    reg [7:0] timer_ns = 70;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            timer_ns <= 8'd70;
        else if (!pause_state) begin
            if (ldr_stable == 1'b1 && state_ns == S_GREEN) begin
                if (tick_1s && timer_ns > 1)
                    timer_ns <= timer_ns - 1;
            end else
                timer_ns <= 8'd70;
        end
        // if pause_state == 1 -> timer_ns conserva su valor
    end

    reg [7:0] timer_ns_yellow = 20;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            timer_ns_yellow <= 8'd20;
        else if (!pause_state) begin
            if (ldr_stable == 1'b1 && state_ns == S_YELLOW) begin
                if (tick_1s && timer_ns_yellow > 1)
                    timer_ns_yellow <= timer_ns_yellow - 1;
            end else
                timer_ns_yellow <= 8'd20;
        end
    end

    reg [7:0] timer_ns_red = 90;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            timer_ns_red <= 8'd90;
        else if (!pause_state) begin
            if (ldr_stable == 1'b1 && state_ns == S_RED) begin
                if (tick_1s && timer_ns_red > 1)
                    timer_ns_red <= timer_ns_red - 1;
            end else
                timer_ns_red <= 8'd90;
        end
    end

    // ============================================================
    // CONTADORES EO
    // ============================================================
    reg [7:0] timer_eo_green = 70;
    reg [7:0] timer_eo_yellow = 20;
    reg [7:0] timer_eo_red = 90;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            timer_eo_green <= 8'd70;
            timer_eo_yellow <= 8'd20;
            timer_eo_red <= 8'd90;
        end else if (!pause_state) begin
            if (ldr_stable == 1'b1 && state_eo == S_GREEN) begin
                if (tick_1s && timer_eo_green > 1)
                    timer_eo_green <= timer_eo_green - 1;
            end else
                timer_eo_green <= 8'd70;

            if (ldr_stable == 1'b1 && state_eo == S_YELLOW) begin
                if (tick_1s && timer_eo_yellow > 1)
                    timer_eo_yellow <= timer_eo_yellow - 1;
            end else
                timer_eo_yellow <= 8'd20;

            if (ldr_stable == 1'b1 && state_eo == S_RED) begin
                if (tick_1s && timer_eo_red > 1)
                    timer_eo_red <= timer_eo_red - 1;
            end else
                timer_eo_red <= 8'd90;
        end
    end

    // ============================================================
    // SELECCIÓN VALOR DISPLAY NS
    // ============================================================
    reg [7:0] display_value;
    always @(*) begin
        case(state_ns)
            S_GREEN:  display_value = timer_ns;
            S_YELLOW: display_value = timer_ns_yellow;
            S_RED:    display_value = timer_ns_red;
            default:  display_value = 0;
        endcase
    end

    wire [3:0] decenas  = display_value / 10;
    wire [3:0] unidades = display_value % 10;

    // ============================================================
    // SELECCIÓN VALOR DISPLAY EO
    // ============================================================
    reg [7:0] display_value_eo;
    always @(*) begin
        case(state_eo)
            S_GREEN:  display_value_eo = timer_eo_green;
            S_YELLOW: display_value_eo = timer_eo_yellow;
            S_RED:    display_value_eo = timer_eo_red;
            default:  display_value_eo = 0;
        endcase
    end

    wire [3:0] decenas_eo  = display_value_eo / 10;
    wire [3:0] unidades_eo = display_value_eo % 10;

    // ============================================================
    // DECODER 7 SEGMENTOS (CÁTODO)
    // ============================================================
    function [6:0] decode(input [3:0] num);
        case (num)
            4'd0: decode = 7'b1111110;
            4'd1: decode = 7'b0110000;
            4'd2: decode = 7'b1101101;
            4'd3: decode = 7'b1111001;
            4'd4: decode = 7'b0110011;
            4'd5: decode = 7'b1011011;
            4'd6: decode = 7'b1011111;
            4'd7: decode = 7'b1110000;
            4'd8: decode = 7'b1111111;
            4'd9: decode = 7'b1110011;
            default: decode = 7'b0000000;
        endcase
    endfunction

    // ============================================================
    // APAGADO DISPLAY POR LDR (AMBOS) -> usa ldr_stable
    // ============================================================
    always @(*) begin
        if (ldr_stable == 1'b0) begin
            seg_dec = 7'b0000000;
            seg_uni = 7'b0000000;
        end else begin
            seg_dec = decode(decenas);
            seg_uni = decode(unidades);
        end
    end

    always @(*) begin
        if (ldr_stable == 1'b0) begin
            seg_dec_eo = 7'b0000000;
            seg_uni_eo = 7'b0000000;
        end else begin
            seg_dec_eo = decode(decenas_eo);
            seg_uni_eo = decode(unidades_eo);
        end
    end

    // ============================================================
    // LÓGICA DEL SEMÁFORO ORIGINAL (con pause_state y ldr_stable)
    // ============================================================
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state_ns <= S_GREEN;
            state_eo <= S_RED;
            count <= 0;

            green_ns  <= 1; yellow_ns <= 0; red_ns <= 0;
            green_eo  <= 0; yellow_eo <= 0; red_eo <= 1;
            yellow_on <= 0;
        end else if (!pause_state) begin
            if (ldr_stable == 1'b0) begin
                // Modo nocturno (oscuro): amarillo parpadeante
                if (count < BLINK_TIME)
                    count <= count + 1;
                else begin
                    yellow_on <= ~yellow_on;
                    count <= 0;
                end

                green_ns  <= 0;
                red_ns    <= 0;
                green_eo  <= 0;
                red_eo    <= 0;
                yellow_ns <= yellow_on;
                yellow_eo <= yellow_on;

            end else begin
                // Modo normal diurno
                case (state_ns)

                    S_GREEN: begin
                        green_ns  <= 1; yellow_ns <= 0; red_ns <= 0;
                        green_eo  <= 0; yellow_eo <= 0; red_eo <= 1;

                        if (count < GREEN_TIME)
                            count <= count + 1;
                        else begin
                            state_ns <= S_YELLOW;
                            state_eo <= S_RED;
                            count <= 0;
                        end
                    end

                    S_YELLOW: begin
                        green_ns  <= 0; yellow_ns <= 1; red_ns <= 0;
                        green_eo  <= 0; yellow_eo <= 0; red_eo <= 1;

                        if (count < YELLOW_TIME)
                            count <= count + 1;
                        else begin
                            state_ns <= S_RED;
                            state_eo <= S_GREEN;
                            count <= 0;
                        end
                    end

                    S_RED: begin
                        green_ns  <= 0; yellow_ns <= 0; red_ns <= 1;

                        case (state_eo)
                            S_GREEN: begin
                                green_eo  <= 1; yellow_eo <= 0; red_eo <= 0;
                                if (count < GREEN_TIME)
                                    count <= count + 1;
                                else begin
                                    state_eo <= S_YELLOW;
                                    count <= 0;
                                end
                            end
                            S_YELLOW: begin
                                green_eo  <= 0; yellow_eo <= 1; red_eo <= 0;
                                if (count < YELLOW_TIME)
                                    count <= count + 1;
                                else begin
                                    state_eo <= S_RED;
                                    state_ns <= S_GREEN;
                                    count <= 0;
                                end
                            end
                            S_RED: begin
                                green_eo  <= 0; yellow_eo <= 0; red_eo <= 1;
                                if (count < RED_TIME)
                                    count <= count + 1;
                                else begin
                                    state_ns <= S_GREEN;
                                    state_eo <= S_RED;
                                    count <= 0;
                                end
                            end
                        endcase
                    end

                endcase
            end
        end
        // if pause_state == 1 -> todo dentro del else if (!pause_state) se congela (se mantienen registros)
    end

    // ============================================================
    // LUCES PEATONALES NS (usa ldr_stable)
    // ============================================================
    always @(*) begin
        if (ldr_stable == 1'b0) begin
            ped_ns_verde = 0;
            ped_ns_rojo  = 0;
        end else begin
            case (state_ns)
                S_RED:    begin
                    ped_ns_verde = 1;  // verde peatonal
                    ped_ns_rojo  = 0;
                end
                S_GREEN,
                S_YELLOW: begin
                    ped_ns_verde = 0;
                    ped_ns_rojo  = 1;  // rojo peatonal
                end
                default: begin
                    ped_ns_verde = 0;
                    ped_ns_rojo  = 1;
                end
            endcase
        end
    end

    // ============================================================
    // LUCES PEATONALES EO (usa ldr_stable)
    // ============================================================
    always @(*) begin
        if (ldr_stable == 1'b0) begin
            ped_eo_verde = 0;
            ped_eo_rojo  = 0;
        end else begin
            case (state_eo)
                S_RED:    begin
                    ped_eo_verde = 1;  // verde peatonal
                    ped_eo_rojo  = 0;
                end
                S_GREEN,
                S_YELLOW: begin
                    ped_eo_verde = 0;
                    ped_eo_rojo  = 1;  // rojo peatonal
                end
                default: begin
                    ped_eo_verde = 0;
                    ped_eo_rojo  = 1;
                end
            endcase
        end
    end

endmodule
